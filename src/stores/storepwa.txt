import { defineStore } from 'pinia';
import { ref, computed } from 'vue';

// Detectando o ambiente
const isCapacitor = typeof Capacitor !== 'undefined'; // Verifica se estamos em um dispositivo nativo (Capacitor)

let CapacitorSQLite: any;
if (isCapacitor) {
  CapacitorSQLite = require('@capacitor-community/sqlite'); // Importa o plugin SQLite do Capacitor
}

export interface Person {
  id: string;
  name: string;
  totalDebts: number;
}

export interface DebtItem {
  id: string;
  personId: string;
  description: string;
  amount: number;
  date: string;
}

export const formatCurrency = (amount: number): string => {
  return new Intl.NumberFormat('pt-BR', {
    style: 'currency',
    currency: 'BRL',
  }).format(amount);
};

export const useDebtStore = defineStore('debts', () => {
  const persons = ref<Person[]>([]);
  const debts = ref<DebtItem[]>([]);

  const initStore = async () => {
    if (isCapacitor) {
      await CapacitorSQLite.create({ database: 'appDB' });

      await CapacitorSQLite.execute({ statement: 'CREATE TABLE IF NOT EXISTS persons (id TEXT PRIMARY KEY, name TEXT)' });
      await CapacitorSQLite.execute({ statement: 'CREATE TABLE IF NOT EXISTS debts (id TEXT PRIMARY KEY, personId TEXT, description TEXT, amount REAL, date TEXT)' });

      await loadPersons();
      await loadDebts();
    }
  };

  const loadPersons = async () => {
    if (isCapacitor) {
      const result = await CapacitorSQLite.query({ statement: 'SELECT * FROM persons' });
      persons.value = result.values as Person[];
    }
  };

  const loadDebts = async () => {
    if (isCapacitor) {
      const result = await CapacitorSQLite.query({ statement: 'SELECT * FROM debts' });
      debts.value = result.values as DebtItem[];
    }
  };

  const saveStorage = async () => {
    if (isCapacitor) {
      for (const person of persons.value) {
        await CapacitorSQLite.execute({
          statement: 'INSERT OR REPLACE INTO persons (id, name) VALUES (?, ?)',
          values: [person.id, person.name],
        });
      }

      for (const debt of debts.value) {
        await CapacitorSQLite.execute({
          statement: 'INSERT OR REPLACE INTO debts (id, personId, description, amount, date) VALUES (?, ?, ?, ?, ?)',
          values: [debt.id, debt.personId, debt.description, debt.amount, debt.date],
        });
      }
    }
  };

  const totalDebts = computed(() => {
    return debts.value.reduce((total, debt) => total + debt.amount, 0);
  });

  const getPersonTotal = (personId: string) => {
    return computed(() => {
      return debts.value.filter(debt => debt.personId === personId)
                         .reduce((total, debt) => total + debt.amount, 0);
    });
  };

  const addPerson = async (name: string) => {
    const newPerson: Person = {
      id: Date.now().toString(),
      name,
      totalDebts: 0,
    };

    persons.value.push(newPerson);
    await saveStorage();
    return newPerson;
  };

  const removePerson = async (id: string) => {
    persons.value = persons.value.filter(person => person.id !== id);
    debts.value = debts.value.filter(debt => debt.personId !== id);
    await saveStorage();
  };

  const addDebt = async (personId: string, description: string, amount: number) => {
    const newDebt: DebtItem = {
      id: Date.now().toString(),
      personId,
      description,
      amount,
      date: new Date().toISOString(),
    };

    debts.value.push(newDebt);
    await saveStorage();
    return newDebt;
  };

  const removeDebt = async (debtId: string) => {
    debts.value = debts.value.filter(debt => debt.id !== debtId);
    await saveStorage();
  };

  return {
    persons,
    debts,
    totalDebts,
    getPersonTotal,
    addPerson,
    removePerson,
    addDebt,
    removeDebt,
    saveStorage,
    initStore,
    loadPersons,
    loadDebts,
  };
});